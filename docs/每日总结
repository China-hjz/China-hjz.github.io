# 每日总结
## 7月11日
#### 归并排序
[**归并排序**](https://oi-wiki.org/basic/merge-sort/) 是一种基于分治思想的排序算法。分治，即分而治之。主要原理是先把一个大问题分解为多个小问题，再分别处理，最后合并。  
##### 好处
复杂度相对会比快排快一点，也比快排好打  
特别是对于~~不让用**Sort**的老师~~需要手打排序的情况下  
 
##### **步骤**如下：  
1. 把长度为n的数组递归分为n段 （分）  
2. 两两和并，每次取两个子序列开头小的数放在一个新序列里 （治）  
3. 把新序列覆盖到旧序列

##### The code there:
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000000],b[1000000];
void sort(int l, int r)
{
	if (l==r) return;
	int mid=(r+l)/2;
	sort(l,mid); sort(mid+1,r);
	int x=l,y=mid+1,z=l;
	while (x <= mid && y <= r)
	{
		if (a[x]>a[y]) b[z++]=a[y++];
		else b[z++]=a[x++];
	}
	while (x<=mid) b[z++]=a[x++];
	while (y<=  r) b[z++]=a[y++];
	for (int i = l ; i <= r ; ++i) a[i]=b[i];
}
int main()
{
	int n; cin >> n;
	for (int i = 0 ; i < n ; ++i) scanf("%d",&a[i]);
	sort(0,n-1);
	for (int i = 0 ; i < n ; ++i) printf("%d\n",a[i]);
	return 0;
}

```
##### 注意
如果题目的输入输出的量很大，要用scanf和printf，速度明显更快。

## 7月12日
#### 线段树
[线段树](https://oi-wiki.org/ds/seg/) 是用于解决区间问题的一种数据结构，用了分治思想。顾名思义“线段树”，它的每个点都是一段线段，维护着一个数组区间。线段树咨询速度很快，修改也很方便。  

既然是分治，那么，一个递归操作就包含`结束条件`、`分别递归`和`合并处理`三个部分。  

一个**最基本的**的线段树会包含以下几个函数👇  
1. build() ———— 用于建树   
2. modify() ——— 用于修改单点元素  
3. query() ——— 用于咨询区间元素  

而且，`tree[x]`一般表示为x节点的区间值（比如区间最大值，区间和之类的），并不需要存储区间开头或结尾。  

除此之外，还有区间修改，一般常用的有`懒惰标记`和`标记永久化`两个方法。`懒惰标记`的方法实现需要一个**额外**的`lazy`数组，用来标记操作。与单点修改不同的是，`懒惰标记`不需要递归到底层，只需要在包含的修改区间标记一下，如果别的操作遍历过这个节点，再**顺便**把标记应用到子节点（一般为push_down()函数）。`懒惰标记`的核心思想是：不使用就不会应用（到子节点）~~真懒~~。大大减少了时间复杂度，一般最坏时间复杂度为O(log n) 。~~可能吧~~

线段树用于解决区间问题，比如区间最大值，区间和之类的，还有 [RMQ](https://oiwiki.com/topic/rmq/) 问题。

不说了，上代码：
```cpp
#include <bits/stdc++.h>
#define int long long
//#define max(a,b) (a>b?a:b)
using namespace std;
//struct linetree
//{
int a[1000000],t[1000000],lazy[1000000];
void build(int l, int r, int x)
{
	if (l==r)
	{
		t[x]=a[l]; 
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,x*2);
	build(mid+1,r,x*2+1);
	t[x]=max(t[x*2+1],t[x*2]);
	return;
}
void push_down(int x)
{
//	t[x]+=lazy[x];
	lazy[x*2]+=lazy[x];
	t[x*2]+=lazy[x];
	lazy[x*2+1]+=lazy[x];
	t[x*2+1]+=lazy[x];
	lazy[x]=0;
}
int query(int l, int r, int x, int L, int R)
{
	if (lazy[x]) push_down(x);
	if (l > R || r < L) return -0x7fffffff;
//	if (l == r) return t[x];
	if (L <= l && r <= R) return t[x];
	int mid=(l+r)/2,ans=-2000000000;
	
	ans=max(ans,query(l,mid,x*2,L,R));
	ans=max(ans,query(mid+1,r,x*2+1,L,R));
	return ans;
}
void modify(int l, int r, int x, int T, int v)
{
	if (l==r) 
	{
		a[T]=v;
		t[x]=v;
		return;
	}
	int mid=(l+r)/2;
	if (lazy[x]) push_down(x);
	if (T <= mid) modify(l,mid,x*2,T,v);
	else modify(mid+1,r,x*2+1,T,v);
	t[x]=max(t[x*2+1],t[x*2]);
	return;
}

void modifymax(int l, int r, int x, int L, int R, int value)
{
	if (l >= L && r <= R)
	{
		lazy[x]+=value;
		t[x]+=value;
		return;
	}
//	if (l > R || r < L) return;
	if (lazy[x]) push_down(x);
	int mid=(l+r)/2;
	if (L <= mid)modifymax(l,mid,x*2,L,R,value);
	if (R > mid) modifymax(mid+1,r,x*2+1,L,R,value);
	t[x]=max(t[x*2],t[x*2+1]);
}
//};
signed main()
{
	int n,m,x,y,z;
	scanf("%lld",&n);
	for (int i = 1 ; i <= n ; ++i) scanf("%lld",&a[i]);
	build(1,n,1);
	scanf("%lld",&m);
	for (int i = 0 ; i < m ; ++i) 
	{
		scanf("%lld",&x);
		if (x == 1)
		{
			scanf("%lld%lld%lld",&x,&y,&z);
			modifymax(1,n,1,x,y,z);
		} else {
			scanf("%lld%lld",&x,&y);
			printf("%lld\n",query(1,n,1,x,y));
		}
	}
	return 0;
}
```

##### 其他
一些GMOJ上的例题：  
- [【线段树】最大值（新版）](https://gmoj.net/junior/#main/show/1380)  
[代码](https://gmoj.net/junior/#main/code/547063)
- [【线段树】最大值](https://gmoj.net/junior/#main/show/1379)  
[代码](https://gmoj.net/junior/#main/code/546768)
- [维护序列（seq）](https://gmoj.net/junior/#main/show/2262)  
[代码](https://gmoj.net/junior/#main/code/547521)

![Jimmy](https://cdn.luogu.com.cn/upload/image_hosting/xqq856yn.png)

## 7月13日
#### [NOI2001] 食物链  
题目传送门：[洛谷P2024](https://www.luogu.com.cn/problem/P2024) && [gmoj初中1373](https://gmoj.net/junior/#main/show/1373)  

#### 大意
有三种动物分别为A，B，C，关系是：A吃B，B吃C，C吃A。给出K句话，表示每个动物的具体关系，问不成立的关系有多少。  

#### 思路
这题要用到一种特殊的并查集：种类并查集。  
这种并查集分为多个序列，在本题为ABC三个序列，分别为3个种类的动物。
![](https://cdn.luogu.com.cn/upload/image_hosting/cucvmlwz.png)         
这种方法处理方式也是很奇怪，即如果一个动物和自己群系的另一个动物（序列）有共同祖先的话，说明它和那个动物是同类。  
如果一个动物和下一个群系的另一个动物有共同祖先，说明它吃那个动物。
如果一个动物和上一个群系的另一个动物有共同祖先，说明它被那个动物吃。  

利用这个规律，我们就可以判断话是否为真了，只需要记住这三点  
- 如果Y吃X，那么X就不可能吃Y
- 如果Y吃X，那么X就不可能和Y是同类
- 如果X和Y是同类，那么X就不可能吃Y  

再加上题目说的
```
1） 当前的话与前面的某些真的话冲突，就是假话；

2） 当前的话中X或Y比N大，就是假话；

3） 当前的话表示X吃X，就是假话。
```
就可以判断是否是假话了。如果不是假话，再判断是否是X吃Y，还是X和Y是同类。  
如果X吃Y，就把X和下一个群系的Y连起来，表示X吃Y。（A、B、C都要！！）  
如果X和Y是同类，就把X和当前群系的Y连起来，表示X和Y是同类。（A、B、C都要！！）  

代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[150001],ans=0,n,m,x,y,z;
int find(int x)
{
	if (f[x]==x) return x;
	return f[x]=find(f[x]);
}
void merge(int x, int y)
{
	f[find(x)]=find(y);
}
int main()
{
	cin >> n >> m;
	for (int i = 0 ; i <= 150000 ; ++i)
	{
		f[i]=i;
	}
	for (int i = 0 ; i < m ; ++i)
	{
		cin >> z >> x >> y;
		if (x > n || y > n) ans++;
		else if (z == 2)
		{
			if (find(x)==find(y) || find(x+n)==find(y+n) || find(x+n*2)==find(y+n*2) || find(x)==find(y+n*2) || find(x+n)==find(y) || find(x+n*2)==find(y+n)) {ans++;continue;}
			merge(x,y+n);
			merge(x+n,y+n*2);
			merge(x+n*2,y);
		} else if (z == 1)
		{
			if (find(x)==find(y+n) || find(x+n)==find(y+n*2) || find(x+n*2)==find(y) || find(x)==find(y+n*2) || find(x+n)==find(y) || find(x+n*2)==find(y+n)) {ans++;continue;}
			merge(x,y);
			merge(x+n,y+n);
			merge(x+n*2,y+n*2);
		}
	}
	cout << ans <<endl;
	return 0;
}
```

#### 其他例题
- [gmoj初中1375 【并查集】奇偶游戏](https://gmoj.net/junior/#main/show/1375)
#### 写在最后
并查集数组记得开三倍！！！
